
###------- internatinal Page-----------
##Tools Used
##OpenAI ChatGPT

##Prompts 
##Asked ChatGPT to help me design Python helper functions for time series analysis in my Dash app.
##prompt: “How to Write a python function to compute a rolling 5-year window of quarterly housing price data.”
##prompt: “Help me compute average quarter-over-quarter growth and annualized CAGR in python.”

##Where AI Output Was Used
##
##give function avg_qoq_growth_pct() and annualised_cagr_pct() to compute average quarter-over-quarter growth rate and CAGR
##Adjusted the code to handle edge cases (e.g., style, delete empty DataFrames, insufficient rows, divide-by-zero protection).


##Verification and Edits
## # delete “Emerging market economies (aggregate)”、"Advanced economies"，Keep country data（AI helped）
        mask_agg = df["country"].str.contains("economies|aggregate", case=False, na=False)
        df = df[~mask_agg].copy()

##Average chain growth rate(AI helped) 
def avg_qoq_growth_pct(window_df: pd.DataFrame, column_name: str): 
if len(window_df) < 2: 
   return None 
s = window_df[column_name].astype(float) 
qoq = s.pct_change().dropna() 
if qoq.empty: 
   return None
return float(qoq.mean() * 100.0)

##Compound Annualised Growth Rate (CAGR) (AI helped) 
def annualised_cagr_pct(window_df: pd.DataFrame, column_name: str): 
if len(window_df) < 2: 
   return None 
s = window_df[column_name].astype(float) 
start = float(s.iloc[0]) end = float(s.iloc[-1]) 
quarters = len(window_df) - 1 
if start <= 0 or quarters <= 0: 
   return None 
cagr = (end / start) ** (4.0 / quarters) - 1.0 
return float(cagr * 100.0)

###------- States Page-----------
# ChatGPT was used as a learning aid while developing this page.
# Helping me understand and correct errors I encountered in my code.
# For example, ChatGPT guided me in using callbacks and functions to make the program fully interactive,
# and it showed me how to convert the calendar so that months could be represented numerically and pulled in order.
# When I made small mistakes, ChatGPT explained where I went wrong and why.

# AI aid 
#CoPilot on VS Code helped automaticly as well (not always helpful).
#this callback function had some orignial errors I needed help identifing so it was used for corrections
@callback(
    Output("kpi-median-price", "children"), 
    Output("selected-month-value", "children"),  
    Output("pct-change", "children"),  
    Output("irr-text", "children"),  
    Output("pct-line", "figure"), 
    Input("state-dropdown", "value"), 
    Input("year-dropdown", "value"), 
    Input("month-dropdown", "value"),  
    Input("refresh", "n_clicks"), 
)

def update_kpi(selected_state, sel_year, sel_month, _):
    # --- Step 1: get selected state column ---
    if selected_state not in df.columns:
        kpi_text = month_text = pct_text = irr_text = "State not found"
        return kpi_text, month_text, pct_text, irr_text, px.line()

    selected_col = df[selected_state]  
    latest_val = selected_col.iloc[-1]
    kpi_text = f"${latest_val:,.0f}" if pd.notna(latest_val) else "—"

    # --- Step 2: check for year/month selection ---
    if not sel_year or not sel_month:
        return kpi_text, "Select a year and month", "Select a year and month", "Select a year and month", px.line()

    # --- Step 3: get the timestamp for selected year/month ---
    col_name = ym_to_col.get((int(sel_year), int(sel_month)))

    # --- Step 4: handle missing data ---
    if col_name is None or pd.isna(selected_col.get(col_name, None)):
        month_text = f"{selected_state} — {calendar.month_name[int(sel_month)]} {sel_year}: —"
        pct_text = f"{selected_state}: —"
        irr_text = f"{selected_state}: —"
        return kpi_text, month_text, pct_text, irr_text, px.line()

    # --- Step 5: get value for selected month ---
    sel_val = selected_col[(selected_col.index.year == int(sel_year)) & (selected_col.index.month == int(sel_month))].iloc[0]
    month_text = f"{selected_state} — {calendar.month_name[int(sel_month)]} {sel_year}: ${sel_val:,.0f}"

    # --- Step 6: percent change ---
    if sel_val == 0 or pd.isna(latest_val):
        pct_text = f"{selected_state}: N/A (insufficient data)"
    else:
        pct = (latest_val - sel_val) / sel_val * 100.0
        pct_text = f"{selected_state}: {pct:+.2f}% since {calendar.month_name[int(sel_month)][:3]} {sel_year}"

    # --- Step 7: annualized IRR ---
    months_diff = (latest_dt.year - int(sel_year)) * 12 + (latest_dt.month - int(sel_month))
    if months_diff <= 0 or sel_val <= 0 or pd.isna(latest_val):
        irr_text = f"{selected_state}: IRR N/A (insufficient or invalid data)"
    else:
        annualized_irr = (latest_val / sel_val) ** (12.0 / months_diff) - 1.0
        irr_text = f"{selected_state}: {annualized_irr*100:.2f}% annualized"

    # --- Step 8: time series for plotting ---
    start_dt = pd.Timestamp(year=int(sel_year), month=int(sel_month), day=1)
    ts_window = selected_col[(selected_col.index >= start_dt) & (selected_col.index <= latest_dt)]

    # --- Step 9: create Plotly figure ---
    fig = px.line(
        x=ts_window.index,
        y=ts_window.values,
        labels={"x": "Date", "y": "Median House Price ($)"},
        title=None
    )
    fig.update_layout(margin=dict(t=10, r=10, b=10, l=10), height=280, hovermode="x unified")
    fig.update_yaxes(tickprefix="$", separatethousands=True)

    print(f"Selected state: {selected_state}, Year/Month: {sel_year}/{sel_month}")
    print(f"Latest val: {latest_val}, Selected val: {sel_val}")
    print(f"ts_window length: {len(ts_window)}")
    
    # --- Step 10: return all results ---
    return kpi_text, month_text, pct_text, irr_text, fig

###------- Home Page-----------
AI was used to assist in finding out where my call back was going wrong in the last step 
# member = df[df["Name"] == selected_name].iloc[0]
I orginally did not actually tell it where to pull from and just had 
        member= df[df["Name"] == selected_name].iloc


###Dashboard Layout
#AI was used to help learn about dbc and plotly. Specifically, about their methods and how they interact with other parts of the code
#AI was also used to help deploy to render by providing the group with which versions of the packages were compatible with python version 3.13.4
#Used AI to help with layout placement, such as how to place the legend of plotly graphs, as well as how to get hide the modebar of the graphs.

